#!/usr/bin/python
# handin_240.py
#
# Main handin script for students to use to hand in their homework files. Needs
# a .cfg file to know how to handle each file (see the usage in README.md for
# details).
#
# Usage:
#   - cd into the directory with all of the necessary files
#   - Run script with the homework number as the argument:
#       ./handin_240 hw8
#   - If the student wishes to submit an incomplete homework (i.e. with certain
#     files missing or unable to compile) they may run the script with the -f flag

import os;
import shutil;
import optparse;

from env import *;
import hw_code_maker;

###################### Some cool output formatting stuff #######################
class bcolors:
    HEADER = "\033[95m";
    OKBLUE = "\033[94m";
    OKGREEN = "\033[92m";
    WARNING = "\033[93m";
    FAIL = "\033[91m";
    ENDC = "\033[0m";
    BOLD = "\033[1m";
    UNDERLINE = "\033[4m";

# Some useful constants in the scope of this script
ERR_NOEXIST     = 0;
ERR_NOCOMPILE   = 1;
ERR_FAILTEST    = 2;

# A line of 80 *'s, to mark beginning and end of a header
HEADER_LEN = 80;
HEADER_LINE = "*" * HEADER_LEN + "\n";

# Generic error handler. If fatal is true, then the error will cause the program
# to terminate. Note that if cleanup is necessary in the case of an error (i.e.
# deleting temporary directories), then fatal should be set to false.
def error(message, fatal=False):
    print(bcolors.FAIL + "ERROR: " + bcolors.ENDC + message);
    if (fatal):
        exit(255);
    else:
        return 255;

# Generic warning handler.
def warning(message):
    print(bcolors.WARNING + "WARNING: " +bcolors.ENDC + message);

def writeHeaderLine(header):
    maxLen = HEADER_LEN - 2;    # Beginning and ending "*"
    remaining = maxLen - len(header);
    firstHalf = remaining // 2;
    secondHalf = remaining - firstHalf;
    headerLine = "*" + (" " * firstHalf) + header + (" " * secondHalf) + "*" + "\n";
    return headerLine;

# Returns a tuple of (options, args) parsed from the command line.
# Raises an error (and exits) if no arg for hwNum is given.
def getArgs():
    usage = "usage: %prog [-f] hwNum";
    parser = optparse.OptionParser(usage=usage)
    parser.add_option("-f", "--force", action="store_true", dest="force",
                      help="force handin even with bad files");
    (options, args) = parser.parse_args();
    if (len(args) != 1):
        parser.error("Must specify homework number as arg");
    return (options, args);

def checkValidOp(opString):
    # For use if there is an error
    badOp = "\nOffending instruction: '" + opString + "'";
    opArr = opString.split();
    if (len(opArr) < 2):
        error("Not enough args in config file" + badOp, fatal=True);
    handler = opArr[0];
    if (not isValidHandlerChar(handler)):
        error("Invalid handler char in config file" + badOp, fatal=True);

def parseConfig(configPath):
    if (not os.path.exists(configPath)):
        error("no such config file. Are you sure the hw number is correct?", fatal=True);
    configFile = open(configPath, "r");
    opArray = configFile.read().strip().split("\n");
    result = [];
    badLine = False;

    # Check validity of parsed operations
    for (i, line) in enumerate(opArray):
        # Remove line if empty or a comment
        if ((badLine) or (len(line) == 0) or (line[0] == "#")):
            continue;
        if (line == "rl_config"):       # Skip RL's config lines
            badLine = True;
            continue;
        checkValidOp(line);
        # Only append to result array if everything checks out
        result.append(line);

    configFile.close();
    return result;

def isValidHandlerChar(handler):
    if ((len(handler) != 1) or (handler not in HANDLER_CHARS)):
        return False;
    else:
        return True;

def getOpError(mainFile, errType):
    if (errType == ERR_NOEXIST):
        errMessage = "file does not exist";
    elif (errType == ERR_NOCOMPILE):
        errMessage = "failed to compile";
    elif (errType == ERR_FAILTEST):
        errMessage = "failed TA testbench";
    else:
        errMessage = "unspecified error"
    return mainFile + ": " + bcolors.FAIL + errMessage + bcolors.ENDC;

def checkExistence(opArr):
    hasError = not os.path.exists("./" + opArr[1]);
    return hasError;

# TODO: checkCompilation(), checkTATB()

def doOperation(opString, personalOutput):
    opArr = opString.split();
    handler = opArr[0];
    mainFile = opArr[1];
    hasErrors = False;

    if (handler == "t"):
        hasErrors = checkExistence(opArr);
        if (hasErrors):
            output = getOpError(mainFile, ERR_NOEXIST);
            print(output);
            personalOutput = personalOutput + output + "\n";
            return (hasErrors, personalOutput);
        (hasErrors, vcsOutput) = checkCompilation(opArr);
        if (hasErrors):
            output = getOpError(mainFile, ERR_NOCOMPILE);
            print(output + "\n" + vcsOutput);
            personalOutput = personalOutput + output + "\n" + vcsOutput;
            return (hasErrors, personalOutput);
        (hasErrors, simOutput) = checkTATB(opArr);
        if (hasErrors):
            output = getOpError(mainFile, ERR_FAILTEST);
            print(output + "\n" + simOutput);
            personalOutput = personalOutput + output + "\n" + simOutput;
            return (hasErrors, personalOutput);
    elif (handler == "c"):
        hasErrors = checkExistence(opArr);
        if (hasErrors):
            output = getOpError(mainFile, ERR_NOEXIST);
            print(output);
            personalOutput = personalOutput + output + "\n";
            return (hasErrors, personalOutput);
        (hasErrors, vcsOutput) = checkCompilation(opArr);
        if (hasErrors):
            output = getOpError(mainFile, ERR_NOCOMPILE);
            print(output + "\n" + vcsOutput);
            personalOutput = personalOutput + output + "\n" + vcsOutput;
            return (hasErrors, personalOutput);
    elif (handler == "e"):
        hasErrors = checkExistence(opArr);
        if (hasErrors):
            output = getOpError(mainFile, ERR_NOEXIST);
            print(output);
            personalOutput = personalOutput + output + "\n";
            return (hasErrors, personalOutput);
        else:
            print(mainFile + ": file exists, good");

    return (hasErrors, personalOutput);

def createErrLog(contents, path="."):
    fd = open(path + "/errors.log", "w");

    # Remove formatting characters
    contents = contents.replace(bcolors.HEADER, "");
    contents = contents.replace(bcolors.OKBLUE, "");
    contents = contents.replace(bcolors.OKGREEN, "");
    contents = contents.replace(bcolors.WARNING, "");
    contents = contents.replace(bcolors.FAIL, "");
    contents = contents.replace(bcolors.ENDC, "");
    contents = contents.replace(bcolors.BOLD, "");
    contents = contents.replace(bcolors.UNDERLINE, "");

    fd.write(contents);
    fd.close();

def getOutputHeader(hwNum, studentID):
    outputHeader = HEADER_LINE;
    outputHeader += writeHeaderLine("18240: " + hwNum);
    outputHeader += writeHeaderLine("Error log for: " + studentID);
    outputHeader += HEADER_LINE;
    return outputHeader;

# Returns True on success, False on failure
def doHandin(hwNum, studentID, filesToSubmit, badFiles=None):
    # TODO: complete this function
    studentDir = HANDIN_DIR + "/" + hwNum + "/" + studentID;

    # Check if student exists in handin directory
    if (not os.path.exists(studentDir)):
        reason = "your handin directory was not found. Are you sure you are " + \
                 "enrolled? Please contact course staff if the problem persists.";
        error(reason);
        return False;

    for fileName in filesToSubmit:
        path = "./" + fileName;
        # Since these files passed the check, they should exist, but just in case
        if (not os.path.exists(path)):
            error("File " + fileName + " does not exist. File not copied.");
        shutil.copy(path, studentDir);
    if (badFiles != None):
        badFilesDir = studentDir + "/badFiles";
        if (not os.path.exists(badFilesDir)):
            os.mkdir(badFilesDir);
        shutil.copy("./errors.log", badFilesDir);
        for fileName in badFiles:
            path = "./" + fileName;
            if (not os.path.exists(path)):
                continue;
            shutil.copy(path, badFilesDir);

    return True;

def main():
    exitStatus = 0;
    (options, args) = getArgs();

    # Save relevant fields
    isForced = options.force;
    hwNum = args[0];
    selfID = os.getlogin().lower();     # Get student's Andrew ID

    # Initialize variables
    personalOutput = getOutputHeader(hwNum, selfID);
    hasAnyErrors = False;
    filesToSubmit = [];
    badFiles = [];

    # Parse config file and do relevant operations
    opArray = parseConfig(CFG_DIR + "/" + hwNum + ".cfg");
    for op in opArray:
        (hasErrors, personalOutput) = doOperation(op, personalOutput);
        if (hasErrors):
            hasAnyErrors = True;
            badFiles.append(op.split()[1]);
        else:
            # No errors, so must be a valid file
            filesToSubmit.append(op.split()[1]);

    # Result strings WITH COLORS \o/
    handinCreated = bcolors.OKGREEN + "Handin complete." + bcolors.ENDC;
    handinNotCreated = bcolors.FAIL + "Handin not complete." + bcolors.ENDC;

    attemptHandin = True;
    # Check if handin had any errors
    if (len(badFiles) < 1):
        badFiles = None;
    if (hasAnyErrors):
        warning = bcolors.WARNING + "WARNING: " + bcolors.ENDC;
        print("\n" + warning + "errors detected! See errors.log for details.\n");
        createErrLog(personalOutput);
        if (not isForced):
            attemptHandin = False;
            print("If you wish to submit an incomplete homework, then run the " +
            "handin script again with the '-f' flag.");
        else:
            print(warning + "you are attempting to submit homework with errors! " +
                  "You will NOT receive any credit for files with errors.\n");
            print("If this is intentional on your part, type 'yes' and press Enter.");
            agreement = raw_input("I agree to hand in files with errors: ");
            if (agreement != "yes"):
                attemptHandin = False;

    if (attemptHandin):
        handinSuccessful = doHandin(hwNum, selfID, filesToSubmit, badFiles);
        if (handinSuccessful):
            print("\n" + handinCreated);
        else:
            print("\n" + handinNotCreated);
        # Create output PDF
        hw_code_maker.main(hwNum, selfID);
        print("\nCode printout created as " + hwNum + "_code.pdf");
        print(bcolors.WARNING + "Please don't forget to submit this PDF to Gradescope!"
                + bcolors.ENDC);
    else:
        print("\n" + handinNotCreated);

    return exitStatus;

exit(main());
