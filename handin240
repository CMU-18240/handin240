#!/usr/bin/python
# handin240.py
#
# Main handin script for students to use to hand in their homework files. Needs
# a .cfg file to know how to handle each file (see the usage in README.md for
# details).
#
# Usage:
#   - cd into the directory with all of the necessary files
#   - Run script with the homework number as the argument:
#       ./handin240 hw8
#   - If the student wishes to submit an incomplete homework (i.e. with certain
#     files missing or unable to compile) they may run the script with the -f flag
#
# Bill Nace <wnace@cmu.edu>         - Reportlab PDF generation
# Edric Kusuma <ekusuma@cmu.edu>    - Student file handin

from env import *;

import os;
import shutil;
import optparse;
import subprocess;
import json;
import glob;

import reportlab

from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfgen import canvas
from reportlab.lib.units import inch
from reportlab.lib import colors
import reportlab.rl_config

from contextlib import contextmanager

###################### Some cool output formatting stuff #######################
class bcolors:
    HEADER = "\033[95m";
    OKBLUE = "\033[94m";
    OKGREEN = "\033[92m";
    # Change from yellow (hard to read on white) to magenta
    #WARNING = "\033[93m";
    WARNING = "\033[95m";
    FAIL = "\033[91m";
    ENDC = "\033[0m";
    BOLD = "\033[1m";
    UNDERLINE = "\033[4m";
################################################################################

# A line of 80 *'s, to mark beginning and end of a header
HEADER_LEN = 80;
HEADER_LINE = "*" * HEADER_LEN + "\n";

# Some useful constants in the scope of this script
ERR_NOEXIST     = 0;
ERR_NOCOMPILE   = 1;
ERR_FAILTEST    = 2;

################################################################################
#                           Code for the handin script                         #
################################################################################

class Operation:
    """Class that holds the necessary information for a problem's operations

    Attributes:
        number (int): Problem number
        existFiles ([str]): List of files to check for existence.
        compileFiles ([str]): List of files to compile.
        testFiles ([str]): List of TA testbenches to run against. (WIP)
        specificModules ([str]): Name of modules to compile for.
        hasErrors (bool): True if there is an error with the problem, False
            otherwise.
        err (str): Output of error.

    """
    def __init__(self):
        self.number = None;
        self.existFiles = None;
        self.compileFiles = None;
        self.testFiles = None;
        self.specificModules = None;
        self.hasErrors = False;
        self.err = "";
        self.useWildcard = False;

    def checkWildcard(self):
        tempExistFiles = set();
        tempCompileFiles = set();

        if (self.existFiles != None):
            for f in self.existFiles:
                # Add all the wildcard files
                if ("*" in f):
                    self.useWildcard = True;
                    allFiles = set(glob.glob(f));
                    tempExistFiles = tempExistFiles.union(allFiles);
                else:
                    tempExistFiles.add(f);
            # Convert to a list for ordering
            self.existFiles = sorted(list(tempExistFiles));
        if (self.compileFiles != None):
            for f in self.compileFiles:
                if ("*" in f):
                    allFiles = set(glob.glob(f));
                    tempCompileFiles = tempCompileFiles.union(allFiles);
                else:
                    tempCompileFiles.add(f);
            self.compileFiles = sorted(list(tempCompileFiles));

    def parseProblem(self, p):
        """Reads the config file (as a dict) and sets the appropriate
        attributes.

        Args:
            p (dict): Dict of the config file (see readme for keys).

        Returns:
            Nothing.

        """
        if (p["number"] != None):
            self.number = p["number"];
        if (p["files"] != None):
            self.existFiles = p["files"];
        if (p["compileFiles"] != None):
            self.compileFiles = p["compileFiles"];
        if (p["testFiles"] != None):
            self.testFiles = p["testFiles"];
        if (p["specificModules"] != None):
            self.specificModules = p["specificModules"];
        self.checkWildcard();

    def getOpError(self, mainFile, errType):
        """Create a formatted error message depending on what was wrong with the
        file.

        Args:
            mainFile (str): Name of a bad file(s).
            errType (int): Error type to classify problem with file.

        Returns:
            (str): Formatted string to display as an error.

        """
        if (errType == ERR_NOEXIST):
            errMessage = "file does not exist";
        elif (errType == ERR_NOCOMPILE):
            errMessage = "failed to compile";
        elif (errType == ERR_FAILTEST):
            errMessage = "failed TA testbench";
        else:
            errMessage = "unspecified error"
        return mainFile + ": " + bcolors.FAIL + errMessage + bcolors.ENDC;

    def checkExistence(self):
        """Checks if every file in a file list exists within the current
        directory. Also lists what files do not exist, if any.

        Args:
            Nothing.

        Returns:
            Nothing.

        """
        if (self.useWildcard):
            print("Files that will be handed in:");
        for f in self.existFiles:
            if (not os.path.exists("./" + f)):
                self.hasErrors = True;
                error = self.getOpError(f, ERR_NOEXIST) + "\n";
                print(error.strip());
                self.err += error;
            else:
                if (self.useWildcard):
                    print("\t{}".format(f));
                else:
                    print(f + ": file exists, good");
        if (self.useWildcard):
            print("If you do not wish to hand in these files, please move " +
                    "them away from your current directory");

    def checkCompilation(self):
        """Tries to compile files from a list using VCS (or vLogan+VCS), and
        checks to see if any compilation errors arise.

        Utilizes a temporary directory called `temp240handin`. As of now, this
        function will actually overwrite that directory if it already exists, so
        hope that the user doesn't have a folder with that name. Will remove
        directory on finish.

        If there is an error, it will also print the compiler message to stdout.

        Args:
            Nothing.

        Returns:
            Nothing.

        """
        # Just in case something failed before, clean up old dir if it exists
        #   Ignore errors because they might not have the directory
        shutil.rmtree("./temp240handin", ignore_errors=True);
        # Create temporary directory for compilation files, and cd into it
        os.mkdir("./temp240handin");
        os.chdir("./temp240handin");

        # Actual files are located a folder up, so:
        fileList = [];
        for fileName in self.compileFiles:
            fileList.append("../" + fileName);  # Add "../" prefix to all files

        # TODO: find some way to suppress output for errors
        if (self.specificModules != None):
            # Command to run vlogan with files
            vloganCmd = ["vlogan", "-q", "-sverilog", "-nc"] + fileList;
            try:
                out = subprocess.check_output(vloganCmd);
            except subprocess.CalledProcessError, e:
                self.hasErrors = True;
                files = ", ".join(fileList).replace("../", "");
                error = self.getOpError(files, ERR_NOCOMPILE) + "\n";
                print(error.strip());
                self.err += error;
                self.err += e.output + "\n";
            # Should only progress to VCS compilation if no errors
            if (not self.hasErrors):
                for module in self.specificModules:
                    vcsCmd = ["vcs", "-q", "-sverilog", "-nc", module];
                    try:
                        out = subprocess.check_output(vcsCmd);
                    except subprocess.CalledProcessError, e:
                        self.hasErrors = True;
                        files = ", ".join(fileList).replace("../", "");
                        error = self.getOpError(files, ERR_NOCOMPILE) + "\n"
                        print(error.strip());
                        self.err += error;
                        self.err += e.output + "\n";
        else:
            vcsCmd = ["vcs", "-q", "-sverilog", "-nc"] + fileList;
            try:
                out = subprocess.check_output(vcsCmd);
            except subprocess.CalledProcessError, e:
                self.hasErrors = True;
                files = ", ".join(fileList).replace("../", "");
                error = self.getOpError(files, ERR_NOCOMPILE) + "\n"
                print(error.strip());
                self.err += error;
                self.err += e.output + "\n";
        if (not self.hasErrors):
            files = ", ".join(fileList).replace("../", "");
            print(files + ": file(s) compile, good");

        # Cleanup
        os.chdir("..");
        shutil.rmtree("./temp240handin");

    # TODO: checkTATB()

    def do(self):
        """Performs an operation based on the op's attributes.

        Args:
            Nothing.

        Returns:
            (str): The error message.

        """
        if (self.existFiles != None):
            self.checkExistence();
            if (self.hasErrors):
                return self.err + "\n";
        if (self.compileFiles != None):
            self.checkCompilation();
            if (self.hasErrors):
                return self.err + "\n";
        return "";

def error(message, fatal=False):
    """Generic error handler.

    If fatal is true, then the error will cause the program to terminate.
        Note that if cleanup is necessary in the case of an error (i.e. deleting
        temporary directories), then fatal should be set to false.

    Args:
        message (string): A message that describes the error.
        fatal (bool): Whether or not the message is fatal (and therefore will
            exit rather than return).

    Returns:
        (int): A non-zero exit code, to signify an error.

    """
    print(bcolors.FAIL + "ERROR: " + bcolors.ENDC + message);
    if (fatal):
        exit(255);
    else:
        return 255;

def warning(message):
    """Generic warning handler.

    Args:
        message (string): A message that describes the warning.

    Returns:
        Nothing

    """
    print(bcolors.WARNING + "WARNING: " +bcolors.ENDC + message);

def writeHeaderLine(header, filled=False):
    """Used to write a line in the header for the errors.log file.

    Args:
        header (string): Text to write in one line of the header.

    Returns:
        (string): Formatted header line string.

    """
    maxLen = HEADER_LEN - 2;    # Beginning and ending "*"
    header = " " + header + " ";
    remaining = maxLen - len(header);
    firstHalf = remaining // 2;
    secondHalf = remaining - firstHalf;
    if (filled):
        filler = "*";
    else:
        filler = " ";
    headerLine = "*" + (filler * firstHalf) + header + (filler * secondHalf) + \
                 "*" + "\n";
    return headerLine;

def getArgs():
    """Uses optparse to get script options and args from command line.
    Raises an error (and exits) if no arg for hwNum is given.

    Args:
        Nothing

    Returns:
        (obj): An optparse object whose attributes correspond to the options
            defined via add_option().
        (arr): Array of strings, the args of the command line call.

    """
    usage = "usage: %prog [-f] hwNum";
    parser = optparse.OptionParser(usage=usage)
    parser.add_option("-f", "--force", action="store_true", dest="force",
                      help="force handin even with bad files");
    (options, args) = parser.parse_args();
    if (len(args) != 1):
        parser.error("Must specify homework number as arg");
    return (options, args);

def parseConfig(configPath):
    """Parses the config JSON file. See README for how these config files must
    be formatted/defined as.

    Raises a fatal error if the path is invalid.

    Args:
        configPath (str): A path leading to the config JSON file. Must be a
            .json file.

    Returns:
        On success:
            (dict): A dictionary that has the parsed JSON mapped onto it. See
                the json module for details on how this is defined.
        On error:
            (None)

    """
    if (not os.path.exists(configPath)):
        error("no such config file. Are you sure the hw number is correct?", fatal=True);
    configFile = open(configPath, "r");
    try:
        config = json.load(configFile);
    except Exception, e:
        print("Error parsing config file:\n{}\n\nPlease contact course staff.".format(e));
        return None;
    configFile.close();
    return config;

def createErrLog(contents, path="."):
    """Writes an errors.log file with the formatting characters removed.

    Args:
        contents (str): The stuff to write to the log file.
        path (str): Path to write errors.log (by default CWD).

    Returns:
        Nothing.

    """
    fd = open(path + "/errors.log", "w");

    # Remove formatting characters
    contents = contents.replace(bcolors.HEADER, "");
    contents = contents.replace(bcolors.OKBLUE, "");
    contents = contents.replace(bcolors.OKGREEN, "");
    contents = contents.replace(bcolors.WARNING, "");
    contents = contents.replace(bcolors.FAIL, "");
    contents = contents.replace(bcolors.ENDC, "");
    contents = contents.replace(bcolors.BOLD, "");
    contents = contents.replace(bcolors.UNDERLINE, "");

    fd.write(contents);
    fd.close();

def getOutputHeader(hwNum, studentID):
    """Writes a formatted header that details hwNum and Andrew ID.

    Args:
        hwNum (str): Number of assignment (i.e. 'hw1').
        studentID (str): Andrew ID of the student.

    Returns:
        (str): Populated header.

    """
    outputHeader = HEADER_LINE;
    outputHeader += writeHeaderLine("18240: " + hwNum);
    outputHeader += writeHeaderLine("Error log for: " + studentID);
    outputHeader += HEADER_LINE;
    return outputHeader;

def checkFs(studentID, studentDir):
    """Checks AFS permissions for a student.

    Args:
        studentID (str): Andrew ID of the student.
        studentDir (str): Path to the folder to check permissions for.

    Returns:
        (bool): True if student has write permissions, False otherwise (and if
            student directory does not exist).

    """
    fsCmd = ["fs", "la", studentDir];
    perms = subprocess.check_output(fsCmd).split();
    try:
        idIndex = perms.index(studentID);
        selfPerms = perms[idIndex:];
    except ValueError:
        error("unable to figure out student permissions for handin dir. " +
              "Please contact course staff if the problem persists.");
        return False;

    # Has write permissions
    return "rlidwk" in selfPerms[1];

def doHandin(hwNum, studentID, filesToSubmit):
    """Perform the handin tasks. Prints relevant errors on failures.

    Args:
        hwNum (str): Name of the assignment.
        studentID (str): Student's Andrew ID.
        filesToSubmit (set): List of all files to be copied to the handin dir.

    Returns:
        (bool): True on success, False on failure.

    """
    studentDir = HANDIN_DIR + "/" + hwNum + "/" + studentID;

    # Check if student exists in handin directory
    if (not os.path.exists(studentDir)):
        reason = "your handin directory was not found. Are you sure you are " + \
                 "enrolled? Please contact course staff if the problem persists.";
        print("");
        error(reason);
        return False;
    goodPerms = checkFs(studentID, studentDir);
    if (not goodPerms):
        reason = "access to handin directory denied. Are you ";
        reason += "trying to submit past the deadline? If not, please contact ";
        reason += "course staff.";
        error(reason);
        return False;

    for fileName in filesToSubmit:
        path = "./" + fileName;
        # Since these files passed the check, they should exist, but just in case
        if (not os.path.exists(path)):
            continue;
        shutil.copy(path, studentDir);

    return True;


################################################################################
#                           Code for the PDF script                            #
################################################################################

#Open my file, still using the "with" context manager goodness, but
# able to detect if the file isn't found (or other errors)
# See PEP 343 for more background
@contextmanager
def opened_with_error(filename, mode='r'):
    try:
        f = open(filename, mode)
    except IOError as err:
        yield None, err
    else:
        try:
            yield f, None
        finally:
            f.close

class HW_Code_Maker:
    """ Make the HWX_code.pdf file for turnin on Gradescope.

    This class encapsulates the functionality to make the HWX_code.pdf
    file.  Such a file is a single PDF with each problem's file(s)
    pretty-printed.  Many problems do not require code, and so nothing
    will be included in this PDF file for those problems.  Some problems
    have a single file and a few have multiple files.

    The resulting PDF will have pages for each file, in order of the
    problem.

    To use, initialize the object with a homework dictionary describing
    the problems in that homework assignment.  Then, call the make_code
    method.
    """

    LINE_SPACING = 10  # points
    TOP_MARGIN   = .5 * inch # points
    LEFT_MARGIN  = .5 * inch # points
    BOTTOM_MARGIN = .5 * inch # points
    BOTTOM_OF_PAGE = 792 - BOTTOM_MARGIN

    def __init__(self, **kwargs):
        """ Initialize with a dictionary describing the HW problems.

        Keyword Arguments: (both are required)
        number : a string used as the homework number.  Typically 0-A
        problems : an ordered list of problem description dictionaries.
                   Exact format is defined in method print_file().
        """
        self.hw_number = kwargs['number']
        self.problems  = kwargs['problems']
        self.student   = kwargs['student']
        self.line_number = 1
        self.init_xy()
        self.canvas = None

    def init_xy(self):
        """ Set the x and y attributes to be the top of the page. """
        self.x = HW_Code_Maker.LEFT_MARGIN
        self.y = HW_Code_Maker.TOP_MARGIN

    def make_code(self):
        """ Make the PDF file with all homework code files printed. """
        filename = '{}_code.pdf'.format(self.hw_number)
        self.canvas = canvas.Canvas(filename,
                                    bottomup=0,
                                    pagesize=reportlab.lib.pagesizes.letter)
        # Need to add to the searchpath, so we can use a font that we specify
        reportlab.rl_config.TTFSearchPath.append(FONT_DIR)
        sFont = TTFont('SourceCodePro', 'SourceCodePro-Regular.ttf')
        pdfmetrics.registerFont(sFont)
        self.canvas.setFont('SourceCodePro', 10)

        for problem in self.problems:
            if problem['files']:
                for filename in problem['files']:
                    self.page_number = 1
                    self.print_file(filename, problem)
        self.canvas.save()

    def draw_text_object(self, a_string, color_style=None):
        """ Draw a string onto the PDF page at the current position.

        Arguments:
        a_string : which will be printed
        color_style : one of 'None', 'Header', 'Warning'
                      Indicates the string should be black, green or red.

        Returns: Nothing

        Note: The y attribute is updated such that the next string to be
              printed will be on a following line.
        """
        text_object = self.canvas.beginText()
        text_object.setTextOrigin(self.x, self.y)
        text_object.setFont('SourceCodePro', 10)
        if color_style == 'Header':
            text_object.setFillColor(colors.green)
        elif color_style == 'Warning':
            text_object.setFillColor(colors.red)
        else:
            text_object.setFillColor(colors.dimgrey)
        text_object.textLine(text=a_string)
        self.canvas.drawText(text_object)
        self.y += HW_Code_Maker.LINE_SPACING

    def draw_header(self, a_filename, prob_dict):
        """ Draw the header at the top of each page.

        The header is one or two lines at the top of each page in the PDF.
        Printed in Green, the header contains information about the problem,
        point values, drill status and filename.
        If the file has taken more than one page, the following headers
        will include a page number.

        Arguments:
        a_filename : the filename of the file being printed.  Note that this
                     is necessary outside of the prob_dict, as there could
                     be multiple files in the problem and we want to know
                     which is currently printing.
        prob_dict : the dictionary describing the problem.  Full documentation
                    of this dictionary is in the print_file method.

        Returns: Nothing
        """
        self.init_xy()
        prob_number = prob_dict['number']
        prob_drill  = prob_dict['drill']
        prob_points = prob_dict['points']
        if self.page_number == 1:
            to_print = 'Problem {}: [{} points]'.format(prob_number, prob_points)
            if prob_drill:
                to_print = to_print + ' Drill problem'
            self.draw_text_object(to_print, 'Header')
            to_print = 'Filename: {}'.format(a_filename)
            self.draw_text_object(to_print, 'Header')
            # Removed line to preserve anonymity for grading
            # Uncomment if you want to print out student ID as well
            #to_print = '{}'.format(self.student)
            #self.draw_text_object(to_print, 'Header')
        else:
            self.canvas.showPage()
            filename_length = len(a_filename)
            middle_length = 84 - 12 - filename_length - 1
            format_string = 'Filename: {{}} {{:>{}}} {{}}'.format(middle_length)
            to_print = format_string.format(a_filename, 'Page #:', self.page_number)
            self.draw_text_object(to_print, 'Header')
        self.y += HW_Code_Maker.LINE_SPACING # include a blank line
        self.page_number += 1


    def print_file(self, a_filename, prob_dict):
        """ Print a single file into the PDF on one or more pages.

        Each file is 'pretty-printed' in a fixed-width font, with line numbers
        added at the left side.  Note that the line numbers are assumed to
        never be greater than two digits.

        As each line is printed, it is checked for two errors (currently).
        If the line has one or more errors, then it will be printed in Red:
        1) Are there any tab characters on the line.  If so, the tabs are
           replaced by double spaces and an error message is printed after
           the line.
        2) Is the line (with tabs replaced) longer than 80 characters?  If
           so, the first 77 characters of the line are printed, followed
           by three periods ('...').  An error message is then printed which
           specifies how many characters are in the full line.
        Note: a single line could have both errors.

        If the file does not exist, then a red error message is printed
        which states so.

        Arguments:
        a_filename : the filename of the file being printed.  Note that this
                     is necessary outside of the prob_dict, as there could
                     be multiple files in the problem and we want to know
                     which is currently printing.
        prob_dict : a dictionary describing the current homework problem.

        Returns : Nothing

        The dictionary contains the following required keys:
        number : A string with the number of the homework assignment.
        drill : A boolean.  True if this problem is a drill problem.
                            False otherwise.
        points : An integer specifying the number of points for the problem.
        files : A list of filenames required for the problem.  Each element
                in the list is a string.  The elements should be ordered as
                the files should be printed.
                If the problem does not require any files, then this value
                should be a None (i.e. a NoneType)
        """
        self.line_number = 1
        self.draw_header(a_filename, prob_dict)

        with opened_with_error(a_filename) as (f_in, err):
            if err:
                line = 'File {} was not found'.format(a_filename)
                self.draw_text_object(line, color_style='Warning')
            else:
                for line in f_in:
                    if self.y > HW_Code_Maker.BOTTOM_OF_PAGE:
                        self.draw_header(a_filename, prob_dict)
                    contains_tabs = False
                    color_style = 'None'
                    if '\t' in line:
                        contains_tabs = True
                        line = line.replace('\t', '  ')
                        color_style = 'Warning'
                    line = line.rstrip()
                    line_length = len(line)
                    if line_length > 80:
                        to_print = '{:3d} {}...'.format(self.line_number, line[:77]) #truncates to 80 characters.  Ironic comment
                        self.draw_text_object(to_print, color_style='Warning')
                        to_print = 'Line length of {} (max is 80)'.format(line_length)
                        self.draw_text_object(to_print, color_style='Warning')
                    else:
                        to_print = '{:3d} {}'.format(self.line_number, line)
                        self.draw_text_object(to_print, color_style)

                    if contains_tabs:
                        self.draw_text_object('Line contains tabs' +
                               ' (each tab replaced by 2 spaces in this print)',
                               color_style)
                    self.line_number += 1
        self.canvas.showPage()

def makePDF(hwNum, student, problemDictList):
    cfgPath = CFG_DIR + "/" + hwNum + "_cfg.json"
    for prob in problemDictList:
        if (prob["files"] != None):
            for f in prob["files"]:
                if ("*" in f):
                    prob["files"] = glob.glob(f);

    hw_dict = {'number' : hwNum, 'problems' : problemDictList,
               'student' : student}

    maker = HW_Code_Maker(**hw_dict)
    maker.make_code()

def makeOpArray(config):
    """Create an array of Operation objects from a config dict.

    Args:
        config (dict): Dict that represents the assignment's config

    Returns:
        ([Operation]): Array of problem ops.

    """
    opArray = [];
    # Sort problem config array by problem number
    config = sorted(config, key=lambda p: p["number"]);
    for problem in config:
        op = Operation();
        op.parseProblem(problem);
        opArray.append(op);
    return opArray;

def searchCfg(fileName):
    """Case-insensitive search for a target config file in CFG_DIR.

    Args:
        fileName (str): Name of the config file to search for.

    Returns:
        (str): Path to the config file.

    """
    fileList = os.listdir(CFG_DIR);
    for f in fileList:
        if (f.lower() == fileName.lower()):
            return "{}/{}".format(CFG_DIR, f);
    error("no config file found. Are you sure the hw number is correct?", True);

def main():
    (options, args) = getArgs();

    # Save relevant fields
    isForced = options.force;
    hwNum = args[0].lower();            # Make case insensitive
    selfID = os.getlogin().lower();     # Get student's Andrew ID

    # Initialize variables
    personalOutput = getOutputHeader(hwNum, selfID);
    hasAnyErrors = False;
    filesToSubmit = set();

    # Parse config file and do relevant operations
    cfgPath = searchCfg("{}_cfg.json".format(hwNum));
    # Take the proper (case-sensitive) hwNum
    hwNum = cfgPath[cfgPath.rindex("/")+1:cfgPath.index("_cfg.json")];
    config = parseConfig(CFG_DIR + "/" + hwNum + "_cfg.json");
    if (config == None):
        exit(255);
    opArray = makeOpArray(config);

    for op in opArray:
        if (op.existFiles != None):
            filesToSubmit = filesToSubmit.union(set(op.existFiles));
        if (op.compileFiles != None):
            filesToSubmit = filesToSubmit.union(set(op.compileFiles));
        errString = op.do();
        if (op.hasErrors):
            hasAnyErrors = True;
            personalOutput += writeHeaderLine("Problem {}".format(op.number), True);
            personalOutput += errString;

    # Result strings WITH COLORS \o/
    handinCreated = bcolors.OKGREEN + "Handin complete." + bcolors.ENDC;
    handinNotCreated = bcolors.FAIL + "Handin not complete." + bcolors.ENDC;

    attemptHandin = True;
    # Check if handin had any errors
    if (hasAnyErrors):
        warning = bcolors.WARNING + "WARNING: " + bcolors.ENDC;
        print("\n" + warning + "errors detected! See errors.log for details.\n");
        createErrLog(personalOutput);
        if (not isForced):
            attemptHandin = False;
            print("If you wish to submit an incomplete homework, then run the " +
            "handin script again with the '-f' flag.");
        else:
            print(warning + "you are attempting to submit homework with errors! " +
                  "You will NOT receive any credit for files with errors.\n");
            formatStr = "If this is intentional on your part, type '{}' and press Enter: ";
            agreement = raw_input(formatStr.format(hwNum));
            if (agreement != hwNum):
                attemptHandin = False;

    if (attemptHandin):
        handinSuccessful = doHandin(hwNum, selfID, filesToSubmit);
        if (handinSuccessful):
            print("\n" + handinCreated);
        else:
            print("\n" + handinNotCreated);
            return 255;
        # Create output PDF
        makePDF(hwNum, selfID, config);
        formatStr = "\nCode printout created as {}_code.pdf. Please check ";
        formatStr += "that there are no errors in the PDF.";
        print(formatStr.format(hwNum));
        print(bcolors.WARNING + "Please don't forget to submit this PDF to Gradescope!"
                + bcolors.ENDC);
        print(bcolors.WARNING + "Also don't forget your written homework!"
                + bcolors.ENDC);
        return 0;
    else:
        print("\n" + handinNotCreated);
        return 255;

exit(main());
