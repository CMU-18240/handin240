#!/usr/bin/python
# handin240.py
#
# Main handin script for students to use to hand in their homework files. Needs
# a .cfg file to know how to handle each file (see the usage in README.md for
# details).
#
# Usage:
#   - cd into the directory with all of the necessary files
#   - Run script with the homework number as the argument:
#       ./handin240 hw8
#   - If the student wishes to submit an incomplete homework (i.e. with certain
#     files missing or unable to compile) they may run the script with the -f flag
#
# Bill Nace <wnace@cmu.edu>         - Reportlab PDF generation
# Edric Kusuma <ekusuma@cmu.edu>    - Student file handin

from env import *;

import os;
import shutil;
import optparse;
import subprocess;
import json;

import reportlab, os

from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfgen import canvas
from reportlab.lib.units import inch
from reportlab.lib import colors
import reportlab.rl_config

from contextlib import contextmanager

###################### Some cool output formatting stuff #######################
class bcolors:
    HEADER = "\033[95m";
    OKBLUE = "\033[94m";
    OKGREEN = "\033[92m";
    WARNING = "\033[93m";
    FAIL = "\033[91m";
    ENDC = "\033[0m";
    BOLD = "\033[1m";
    UNDERLINE = "\033[4m";

# Some useful constants in the scope of this script
ERR_NOEXIST     = 0;
ERR_NOCOMPILE   = 1;
ERR_FAILTEST    = 2;

# A line of 80 *'s, to mark beginning and end of a header
HEADER_LEN = 80;
HEADER_LINE = "*" * HEADER_LEN + "\n";

################################################################################
#                           Code for the handin script                         #
################################################################################

# Generic error handler. If fatal is true, then the error will cause the program
# to terminate. Note that if cleanup is necessary in the case of an error (i.e.
# deleting temporary directories), then fatal should be set to false.
#
# Args:
#   message (string):
#       A message that describes the error.
#   fatal (bool):
#       Whether or not the message is fatal (and therefore will exit rather than
#       return).
#
# Returns:
#   (int):
#       A non-zero exit code, to signify an error.
def error(message, fatal=False):
    print(bcolors.FAIL + "ERROR: " + bcolors.ENDC + message);
    if (fatal):
        exit(255);
    else:
        return 255;

# Generic warning handler.
#
# Args:
#   message (string):
#       A message that describes the warning.
#
# No return value.
def warning(message):
    print(bcolors.WARNING + "WARNING: " +bcolors.ENDC + message);

# Used to write a line in the header for the errors.log file.
#
# Args:
#   header (string):
#       Text to write in one line of the header.
#
# Returns:
#   (string):
#       Formatted header line string.
def writeHeaderLine(header):
    maxLen = HEADER_LEN - 2;    # Beginning and ending "*"
    remaining = maxLen - len(header);
    firstHalf = remaining // 2;
    secondHalf = remaining - firstHalf;
    headerLine = "*" + (" " * firstHalf) + header + (" " * secondHalf) + "*" + "\n";
    return headerLine;

# Returns a tuple of (options, args) parsed from the command line.
# Raises an error (and exits) if no arg for hwNum is given.
def getArgs():
    usage = "usage: %prog [-f] hwNum";
    parser = optparse.OptionParser(usage=usage)
    parser.add_option("-f", "--force", action="store_true", dest="force",
                      help="force handin even with bad files");
    (options, args) = parser.parse_args();
    if (len(args) != 1):
        parser.error("Must specify homework number as arg");
    return (options, args);

# Parses the hw config JSON and returns a dict with the JS object attributes as
# keys. See the README for how config files must be defined.
def parseConfig(configPath):
    if (not os.path.exists(configPath)):
        error("no such config file. Are you sure the hw number is correct?", fatal=True);
    configFile = open(configPath, "r");
    config = json.load(configFile);
    configFile.close();
    return config;

# Returns a string that is an error message formatted as:
#       fileName: errorType
def getOpError(mainFile, errType):
    if (errType == ERR_NOEXIST):
        errMessage = "file does not exist";
    elif (errType == ERR_NOCOMPILE):
        errMessage = "failed to compile";
    elif (errType == ERR_FAILTEST):
        errMessage = "failed TA testbench";
    else:
        errMessage = "unspecified error"
    return mainFile + ": " + bcolors.FAIL + errMessage + bcolors.ENDC;

# Returns a boolean value
def checkExistence(fileList):
    hasError = False;
    for f in fileList:
        if (not os.path.exists("./" + f)):
            hasError = True;
    return hasError;

def checkCompilation(fileList):
    # Check if we want to compile with specific module
    useSpecificModule = ("m" in fileList);
    try:
        mIndex = fileList.index("m");
        useSpecificModule = True;
        moduleName = fileList[mIndex + 1];
    # Handler char "m" does not exist
    except ValueError, e:
        useSpecificModule = False;

    hasError = False;
    # Output should only be not None if there is an error
    compileOutput = None;
    # Just in case something failed before, clean up old temp240 if it exists
    shutil.rmtree("./temp240", ignore_errors=True);
    # Create temporary directory for compilation files
    os.mkdir("./temp240");
    os.chdir("./temp240");
    # For hiding compilation output
    FNULL = open(os.devnull, "w");
    oldFileList = list(fileList);
    # Add "../" prefix to all files
    fileList = [];
    for fileName in oldFileList:
        fileList.append("../" + fileName);

    # TODO: find some way to suppress output for errors
    if (useSpecificModule):
        vloganCmd = ["vlogan", "-q", "-sverilog", "-nc"] + fileList;
        try:
            out = subprocess.check_output(vloganCmd, stderr=FNULL);
        except subprocess.CalledProcessError, e:
            hasError = True;
            compileOutput = e.output;
        if (not hasError):
            vcsCmd = ["vcs", "-q", "-sverilog", "-nc", moduleName];
            try:
                out = subprocess.check_output(vcsCmd, stderr=FNULL);
            except subprocess.CalledProcessError, e:
                hasError = True;
                compileOutput = e.output + "\n";
    else:
        vcsCmd = ["vcs", "-q", "-sverilog", "-nc"] + fileList;
        try:
            out = subprocess.check_output(vcsCmd, stderr=FNULL);
        except subprocess.CalledProcessError, e:
            hasError = True;
            compileOutput = e.output + "\n";

    # Cleanup
    FNULL.close();
    os.chdir("..");
    shutil.rmtree("./temp240");
    return (hasError, compileOutput);

# TODO: checkTATB()

def doOperation(op, personalOutput):
    handler = op[0];
    fileList = op[1];
    mainFile = fileList[0];
    hasErrors = False;

    if (handler == "t"):
        hasErrors = checkExistence(fileList);
        if (hasErrors):
            output = getOpError(mainFile, ERR_NOEXIST);
            print(output);
            personalOutput = personalOutput + output + "\n";
            return (hasErrors, personalOutput);
        (hasErrors, vcsOutput) = checkCompilation(fileList);
        if (hasErrors):
            output = getOpError(mainFile, ERR_NOCOMPILE);
            print(output + "\n" + vcsOutput);
            personalOutput = personalOutput + output + "\n" + vcsOutput;
            return (hasErrors, personalOutput);
        #(hasErrors, simOutput) = checkTATB(fileList);
        #if (hasErrors):
        #    output = getOpError(mainFile, ERR_FAILTEST);
        #    print(output + "\n" + simOutput);
        #    personalOutput = personalOutput + output + "\n" + simOutput;
        #    return (hasErrors, personalOutput);
        else:
            print(mainFile + ": passes TA testbenches, good");
    elif (handler == "c"):
        hasErrors = checkExistence(fileList);
        if (hasErrors):
            output = getOpError(mainFile, ERR_NOEXIST);
            print(output);
            personalOutput = personalOutput + output + "\n";
            return (hasErrors, personalOutput);
        (hasErrors, vcsOutput) = checkCompilation(fileList);
        if (hasErrors):
            output = getOpError(mainFile, ERR_NOCOMPILE);
            print(output + "\n" + vcsOutput);
            personalOutput = personalOutput + output + "\n" + vcsOutput;
            return (hasErrors, personalOutput);
        else:
            print(mainFile + ": file compiles, good");
    elif (handler == "e"):
        hasErrors = checkExistence(fileList);
        if (hasErrors):
            output = getOpError(mainFile, ERR_NOEXIST);
            print(output);
            personalOutput = personalOutput + output + "\n";
            return (hasErrors, personalOutput);
        else:
            print(mainFile + ": file exists, good");

    return (hasErrors, personalOutput);

def createErrLog(contents, path="."):
    fd = open(path + "/errors.log", "w");

    # Remove formatting characters
    contents = contents.replace(bcolors.HEADER, "");
    contents = contents.replace(bcolors.OKBLUE, "");
    contents = contents.replace(bcolors.OKGREEN, "");
    contents = contents.replace(bcolors.WARNING, "");
    contents = contents.replace(bcolors.FAIL, "");
    contents = contents.replace(bcolors.ENDC, "");
    contents = contents.replace(bcolors.BOLD, "");
    contents = contents.replace(bcolors.UNDERLINE, "");

    fd.write(contents);
    fd.close();

def getOutputHeader(hwNum, studentID):
    outputHeader = HEADER_LINE;
    outputHeader += writeHeaderLine("18240: " + hwNum);
    outputHeader += writeHeaderLine("Error log for: " + studentID);
    outputHeader += HEADER_LINE;
    return outputHeader;

# Returns True on success, False on failure
def doHandin(hwNum, studentID, filesToSubmit, badFiles=None):
    studentDir = HANDIN_DIR + "/" + hwNum + "/" + studentID;

    # Check if student exists in handin directory
    if (not os.path.exists(studentDir)):
        reason = "your handin directory was not found. Are you sure you are " + \
                 "enrolled? Please contact course staff if the problem persists.";
        print("");
        error(reason);
        return False;

    for fileName in filesToSubmit:
        path = "./" + fileName;
        # Since these files passed the check, they should exist, but just in case
        if (not os.path.exists(path)):
            error("File " + fileName + " does not exist. File not copied.");
        shutil.copy(path, studentDir);
    if (badFiles != None):
        badFilesDir = studentDir + "/badFiles";
        if (not os.path.exists(badFilesDir)):
            os.mkdir(badFilesDir);
        shutil.copy("./errors.log", badFilesDir);
        for fileName in badFiles:
            path = "./" + fileName;
            # This handles the case where file does not exist
            if (not os.path.exists(path)):
                continue;
            shutil.copy(path, badFilesDir);

    return True;


################################################################################
#                           Code for the PDF script                            #
################################################################################

#Open my file, still using the "with" context manager goodness, but
# able to detect if the file isn't found (or other errors)
# See PEP 343 for more background
@contextmanager
def opened_with_error(filename, mode='r'):
    try:
        f = open(filename, mode)
    except IOError as err:
        yield None, err
    else:
        try:
            yield f, None
        finally:
            f.close

class HW_Code_Maker:
    """ Make the HWX_code.pdf file for turnin on Gradescope.

    This class encapsulates the functionality to make the HWX_code.pdf
    file.  Such a file is a single PDF with each problem's file(s)
    pretty-printed.  Many problems do not require code, and so nothing
    will be included in this PDF file for those problems.  Some problems
    have a single file and a few have multiple files.

    The resulting PDF will have pages for each file, in order of the
    problem.

    To use, initialize the object with a homework dictionary describing
    the problems in that homework assignment.  Then, call the make_code
    method.
    """

    LINE_SPACING = 10  # points
    TOP_MARGIN   = .5 * inch # points
    LEFT_MARGIN  = .5 * inch # points
    BOTTOM_MARGIN = .5 * inch # points
    BOTTOM_OF_PAGE = 792 - BOTTOM_MARGIN

    def __init__(self, **kwargs):
        """ Initialize with a dictionary describing the HW problems.

        Keyword Arguments: (both are required)
        number : a string used as the homework number.  Typically 0-A
        problems : an ordered list of problem description dictionaries.
                   Exact format is defined in method print_file().
        """
        self.hw_number = kwargs['number']
        self.problems  = kwargs['problems']
        self.student   = kwargs['student']
        self.line_number = 1
        self.init_xy()
        self.canvas = None

    def init_xy(self):
        """ Set the x and y attributes to be the top of the page. """
        self.x = HW_Code_Maker.LEFT_MARGIN
        self.y = HW_Code_Maker.TOP_MARGIN

    def make_code(self):
        """ Make the PDF file with all homework code files printed. """
        filename = 'hw{}_code.pdf'.format(self.hw_number)
        self.canvas = canvas.Canvas(filename,
                                    bottomup=0,
                                    pagesize=reportlab.lib.pagesizes.letter)
        # Need to add to the searchpath, so we can use a font that we specify
        reportlab.rl_config.TTFSearchPath.append(FONT_DIR)
        sFont = TTFont('SourceCodePro', 'SourceCodePro-Regular.ttf')
        pdfmetrics.registerFont(sFont)
        self.canvas.setFont('SourceCodePro', 10)

        for problem in self.problems:
            if problem['files']:
                for filename in problem['files']:
                    self.page_number = 1
                    self.print_file(filename, problem)
        self.canvas.save()

    def draw_text_object(self, a_string, color_style=None):
        """ Draw a string onto the PDF page at the current position.

        Arguments:
        a_string : which will be printed
        color_style : one of 'None', 'Header', 'Warning'
                      Indicates the string should be black, green or red.

        Returns: Nothing

        Note: The y attribute is updated such that the next string to be
              printed will be on a following line.
        """
        text_object = self.canvas.beginText()
        text_object.setTextOrigin(self.x, self.y)
        text_object.setFont('SourceCodePro', 10)
        if color_style == 'Header':
            text_object.setFillColor(colors.green)
        elif color_style == 'Warning':
            text_object.setFillColor(colors.red)
        else:
            text_object.setFillColor(colors.dimgrey)
        text_object.textLine(text=a_string)
        self.canvas.drawText(text_object)
        self.y += HW_Code_Maker.LINE_SPACING

    def draw_header(self, a_filename, prob_dict):
        """ Draw the header at the top of each page.

        The header is one or two lines at the top of each page in the PDF.
        Printed in Green, the header contains information about the problem,
        point values, drill status and filename.
        If the file has taken more than one page, the following headers
        will include a page number.

        Arguments:
        a_filename : the filename of the file being printed.  Note that this
                     is necessary outside of the prob_dict, as there could
                     be multiple files in the problem and we want to know
                     which is currently printing.
        prob_dict : the dictionary describing the problem.  Full documentation
                    of this dictionary is in the print_file method.

        Returns: Nothing
        """
        self.init_xy()
        prob_number = prob_dict['number']
        prob_drill  = prob_dict['drill']
        prob_points = prob_dict['points']
        if self.page_number == 1:
            to_print = 'Problem {}: [{} points]'.format(prob_number, prob_points)
            if prob_drill:
                to_print = to_print + ' Drill problem'
            self.draw_text_object(to_print, 'Header')
            to_print = 'Filename: {}'.format(a_filename)
            self.draw_text_object(to_print, 'Header')
            # Removed line to preserve anonymity for grading
            # Uncomment if you want to print out student ID as well
            #to_print = '{}'.format(self.student)
            #self.draw_text_object(to_print, 'Header')
        else:
            self.canvas.showPage()
            filename_length = len(a_filename)
            middle_length = 84 - 12 - filename_length - 1
            format_string = 'Filename: {{}} {{:>{}}} {{}}'.format(middle_length)
            to_print = format_string.format(a_filename, 'Page #:', self.page_number)
            self.draw_text_object(to_print, 'Header')
        self.y += HW_Code_Maker.LINE_SPACING # include a blank line
        self.page_number += 1


    def print_file(self, a_filename, prob_dict):
        """ Print a single file into the PDF on one or more pages.

        Each file is 'pretty-printed' in a fixed-width font, with line numbers
        added at the left side.  Note that the line numbers are assumed to
        never be greater than two digits.

        As each line is printed, it is checked for two errors (currently).
        If the line has one or more errors, then it will be printed in Red:
        1) Are there any tab characters on the line.  If so, the tabs are
           replaced by double spaces and an error message is printed after
           the line.
        2) Is the line (with tabs replaced) longer than 80 characters?  If
           so, the first 77 characters of the line are printed, followed
           by three periods ('...').  An error message is then printed which
           specifies how many characters are in the full line.
        Note: a single line could have both errors.

        If the file does not exist, then a red error message is printed
        which states so.

        Arguments:
        a_filename : the filename of the file being printed.  Note that this
                     is necessary outside of the prob_dict, as there could
                     be multiple files in the problem and we want to know
                     which is currently printing.
        prob_dict : a dictionary describing the current homework problem.

        Returns : Nothing

        The dictionary contains the following required keys:
        number : A string with the number of the homework assignment.
        drill : A boolean.  True if this problem is a drill problem.
                            False otherwise.
        points : An integer specifying the number of points for the problem.
        files : A list of filenames required for the problem.  Each element
                in the list is a string.  The elements should be ordered as
                the files should be printed.
                If the problem does not require any files, then this value
                should be a None (i.e. a NoneType)
        """
        self.line_number = 1
        self.draw_header(a_filename, prob_dict)

        with opened_with_error(a_filename) as (f_in, err):
            if err:
                line = 'File {} was not found'.format(a_filename)
                self.draw_text_object(line, color_style='Warning')
            else:
                for line in f_in:
                    if self.y > HW_Code_Maker.BOTTOM_OF_PAGE:
                        self.draw_header(a_filename, prob_dict)
                    contains_tabs = False
                    color_style = 'None'
                    if '\t' in line:
                        contains_tabs = True
                        line = line.replace('\t', '  ')
                        color_style = 'Warning'
                    line = line.rstrip()
                    line_length = len(line)
                    if line_length > 80:
                        to_print = '{:3d} {}...'.format(self.line_number, line[:77]) #truncates to 80 characters.  Ironic comment
                        self.draw_text_object(to_print, color_style='Warning')
                        to_print = 'Line length of {} (max is 80)'.format(line_length)
                        self.draw_text_object(to_print, color_style='Warning')
                    else:
                        to_print = '{:3d} {}'.format(self.line_number, line)
                        self.draw_text_object(to_print, color_style)

                    if contains_tabs:
                        self.draw_text_object('Line contains tabs' +
                               ' (each tab replaced by 2 spaces in this print)',
                               color_style)
                    self.line_number += 1
        self.canvas.showPage()

def makePDF(hwNum, student, problemDictList):
    cfgPath = CFG_DIR + "/" + hwNum + "_cfg.json"

    hw_dict = {'number' : hwNum.replace("hw", ""), 'problems' : problemDictList,
               'student' : student}

    maker = HW_Code_Maker(**hw_dict)
    maker.make_code()

def makeOpArray(config):
    opArray = [];
    # Sort problem config array by problem number
    config = sorted(config, key=lambda p: p["number"]);
    for problem in config:
        if (problem["testFiles"] != None):
            files = problem["compileFiles"] + problem["testFiles"];
            if (problem["specificModule"] != None):
                op = ("t", problem["testFiles"], "m", problem["specificModule"]);
            else:
                op = ("t", problem["testFiles"]);
        elif (problem["compileFiles"] != None):
            if (problem["specificModule"] != None):
                op = ("c", problem["compileFiles"], "m", problem["specificModule"]);
            else:
                op = ("c", problem["compileFiles"]);
        elif (problem["files"] != None):
            op = ("e", problem["files"]);
        else:
            continue;
        opArray.append(op);
    return opArray;

def main():
    (options, args) = getArgs();

    # Save relevant fields
    isForced = options.force;
    hwNum = args[0];
    selfID = os.getlogin().lower();     # Get student's Andrew ID

    # Initialize variables
    personalOutput = getOutputHeader(hwNum, selfID);
    hasAnyErrors = False;
    filesToSubmit = set();
    badFiles = set();

    # Parse config file and do relevant operations
    config = parseConfig(CFG_DIR + "/" + hwNum + "_cfg.json");
    opArray = makeOpArray(config);

    for op in opArray:
        (hasErrors, personalOutput) = doOperation(op, personalOutput);
        if (hasErrors):
            hasAnyErrors = True;
            badFiles = badFiles.union(set(op[1]));
        else:
            # No errors, so must be valid file(s)
            filesToSubmit = filesToSubmit.union(set(op[1]));
    # Remove overlap
    badFiles = badFiles.difference(filesToSubmit);

    # Result strings WITH COLORS \o/
    handinCreated = bcolors.OKGREEN + "Handin complete." + bcolors.ENDC;
    handinNotCreated = bcolors.FAIL + "Handin not complete." + bcolors.ENDC;

    attemptHandin = True;
    # Check if handin had any errors
    if (len(badFiles) < 1):
        badFiles = None;
    if (hasAnyErrors):
        warning = bcolors.WARNING + "WARNING: " + bcolors.ENDC;
        print("\n" + warning + "errors detected! See errors.log for details.\n");
        createErrLog(personalOutput);
        if (not isForced):
            attemptHandin = False;
            print("If you wish to submit an incomplete homework, then run the " +
            "handin script again with the '-f' flag.");
        else:
            print(warning + "you are attempting to submit homework with errors! " +
                  "You will NOT receive any credit for files with errors.\n");
            print("If this is intentional on your part, type 'yes' and press Enter.");
            agreement = raw_input("I agree to hand in files with errors: ");
            if (agreement != "yes"):
                attemptHandin = False;

    if (attemptHandin):
        handinSuccessful = doHandin(hwNum, selfID, filesToSubmit, badFiles);
        if (handinSuccessful):
            print("\n" + handinCreated);
        else:
            print("\n" + handinNotCreated);
            return 255;
        # Create output PDF
        makePDF(hwNum, selfID, config);
        print("\nCode printout created as " + hwNum + "_code.pdf");
        print(bcolors.WARNING + "Please don't forget to submit this PDF to Gradescope!"
                + bcolors.ENDC);
        return 0;
    else:
        print("\n" + handinNotCreated);
        return 255;

exit(main());
